<!DOCTYPE html>
<html>
<head>
    <title>SDF Debug Visualization</title>
    <style>
        canvas {
            border: 1px solid #ccc;
        }
        #controls {
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div id="controls">
        <label>Expression: <input type="text" id="expr" value="sqrt(x*x + y*y) - 1" size="50"></label>
        <button onclick="updateViz()">Update</button>
    </div>
    <canvas id="canvas" width="800" height="800"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        // Convert canvas coordinates to world space
        function canvasToWorld(cx, cy) {
            const scale = 4.0; // -2 to +2 in world space
            return {
                x: (cx / width - 0.5) * scale,
                y: (cy / height - 0.5) * scale
            };
        }

        function worldToCanvas(x, y) {
            const scale = 4.0;
            return {
                x: (x / scale + 0.5) * width,
                y: (y / scale + 0.5) * height
            };
        }

        // Evaluate SDF at a point
        function evalSDF(expr, x, y) {
            try {
                return new Function('x', 'y', `return ${expr};`)(x, y);
            } catch (e) {
                console.error('Error evaluating expression:', e);
                return 0;
            }
        }

        // Calculate gradient using finite differences
        function getGradient(expr, x, y) {
            const h = 0.001;
            const dx = (evalSDF(expr, x + h, y) - evalSDF(expr, x - h, y)) / (2 * h);
            const dy = (evalSDF(expr, x, y + h) - evalSDF(expr, x, y - h)) / (2 * h);
            return { dx, dy };
        }

        function drawArrow(fromX, fromY, dx, dy) {
            const len = Math.sqrt(dx*dx + dy*dy);
            if (len < 0.00001) return;
            
            // Normalize and scale
            const scale = 20;
            dx = (dx / len) * scale;
            dy = (dy / len) * scale;

            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(fromX + dx, fromY + dy);
            
            // Arrow head
            const headLen = 5;
            const angle = Math.atan2(dy, dx);
            ctx.lineTo(fromX + dx - headLen * Math.cos(angle - Math.PI/6),
                      fromY + dy - headLen * Math.sin(angle - Math.PI/6));
            ctx.moveTo(fromX + dx, fromY + dy);
            ctx.lineTo(fromX + dx - headLen * Math.cos(angle + Math.PI/6),
                      fromY + dy - headLen * Math.sin(angle + Math.PI/6));
            
            ctx.stroke();
        }

        function updateViz() {
            const expr = document.getElementById('expr').value;
            ctx.clearRect(0, 0, width, height);

            // Draw contour lines
            const contourLevels = [-2, -1.5, -1, -0.5, 0, 0.5, 1, 1.5, 2];
            const gridSize = 4;

            for (let y = 0; y < height; y += gridSize) {
                for (let x = 0; x < width; x += gridSize) {
                    const p = canvasToWorld(x, y);
                    const val = evalSDF(expr, p.x, p.y);
                    
                    // Find closest contour level
                    const closest = contourLevels.reduce((prev, curr) => 
                        Math.abs(curr - val) < Math.abs(prev - val) ? curr : prev
                    );
                    
                    // Draw point if close to a contour
                    if (Math.abs(val - closest) < 0.02) {
                        ctx.fillStyle = val === 0 ? 'red' : 'black';
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
            }

            // Draw gradient arrows
            ctx.strokeStyle = 'blue';
            const arrowSpacing = 40;
            for (let y = arrowSpacing/2; y < height; y += arrowSpacing) {
                for (let x = arrowSpacing/2; x < width; x += arrowSpacing) {
                    const p = canvasToWorld(x, y);
                    const grad = getGradient(expr, p.x, p.y);
                    drawArrow(x, y, -grad.dx, -grad.dy); // Negative because gradient points uphill
                }
            }
        }

        // Initial draw
        updateViz();
    </script>
</body>
</html>
